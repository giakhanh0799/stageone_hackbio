# -*- coding: utf-8 -*-
"""simplecode.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dbqDLMUIdcydyuFLq1d5ZlGslL-zsC2J
"""

#translate DNA to Protein
def dna_to_protein(dna_seq):
    """
    Translate a DNA sequence into a protein sequence.
    Input:
        dna_seq (str): DNA sequence composed of A, T, G, C.
    Output:
        str: Protein sequence (amino acids, single-letter code).
    """
    # Standard genetic code table
    codon_table = {
        'ATA':'I', 'ATC':'I', 'ATT':'I', 'ATG':'M',
        'ACA':'T', 'ACC':'T', 'ACG':'T', 'ACT':'T',
        'AAC':'N', 'AAT':'N', 'AAA':'K', 'AAG':'K',
        'AGC':'S', 'AGT':'S', 'AGA':'R', 'AGG':'R',
        'CTA':'L', 'CTC':'L', 'CTG':'L', 'CTT':'L',
        'CCA':'P', 'CCC':'P', 'CCG':'P', 'CCT':'P',
        'CAC':'H', 'CAT':'H', 'CAA':'Q', 'CAG':'Q',
        'CGA':'R', 'CGC':'R', 'CGG':'R', 'CGT':'R',
        'GTA':'V', 'GTC':'V', 'GTG':'V', 'GTT':'V',
        'GCA':'A', 'GCC':'A', 'GCG':'A', 'GCT':'A',
        'GAC':'D', 'GAT':'D', 'GAA':'E', 'GAG':'E',
        'GGA':'G', 'GGC':'G', 'GGG':'G', 'GGT':'G',
        'TCA':'S', 'TCC':'S', 'TCG':'S', 'TCT':'S',
        'TTC':'F', 'TTT':'F', 'TTA':'L', 'TTG':'L',
        'TAC':'Y', 'TAT':'Y', 'TAA':'_', 'TAG':'_',
        'TGC':'C', 'TGT':'C', 'TGA':'_', 'TGG':'W',
    }

    # Clean input
    dna_seq = dna_seq.upper().replace(" ", "")

    protein = ""
    # Translate in steps of 3 bases (codons)
    for i in range(0, len(dna_seq) - 2, 3):
        codon = dna_seq[i:i+3]
        protein += codon_table.get(codon, 'X')  # 'X' for unknown codon

    return protein

print(dna_to_protein("ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG"))

#calculate Hamming distance
def hamming_distance(str1, str2):
    """
    Calculate the Hamming distance between two strings.
    If lengths differ, pad the shorter one with '-' to make them equal.
    """
    max_len = max(len(str1), len(str2))
    str1 = str1.ljust(max_len, '-')  # pad with '-'
    str2 = str2.ljust(max_len, '-')

    distance = sum(ch1 != ch2 for ch1, ch2 in zip(str1, str2))
    return distance

slack_username = "Khanh"
twitter_handle = "khanh0799"

dist = hamming_distance(slack_username, twitter_handle)
print(f"Hamming distance between '{slack_username}' and '{twitter_handle}' = {dist}")

import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from pathlib import Path


sns.set(style='whitegrid')
plt.rcParams['figure.dpi'] = 120

def load_deg_chr22(path='hbr_uhr_deg_chr22_with_significance.csv'):
    if Path(path).exists():
        deg = pd.read_csv(path)
        # ensure columns exist
        if {'gene','log2FoldChange','padj'}.issubset(deg.columns):
            return deg
    # fallback: synthetic deg table
    rng = np.random.default_rng(2)
    genes = [f'Gene_{i}' for i in range(1,101)]
    lfc = rng.normal(0,2,size=len(genes))
    padj = np.clip(np.exp(-np.abs(lfc))*rng.random(len(genes)), 1e-10, 1)
    deg = pd.DataFrame({'gene':genes,'log2FoldChange':lfc,'padj':padj})
    # add a few named genes for illustration
    deg.loc[0,'gene']='IGLC3'
    deg.loc[1,'gene']='IGLC2'
    return deg

def load_normalized_counts(path='hbr_uhr_top_deg_normalized_counts.csv'):
    if Path(path).exists():
        df = pd.read_csv(path, index_col=0)
        return df
    # fallback synthetic example (6 genes x 6 samples HBR/UHR)
    genes = ['IGLC3','IGLC2','CDC45','MPPED1','RP3-323A16.1','RP5-1119A7.17']
    samples = ['HBR_1','HBR_2','HBR_3','UHR_1','UHR_2','UHR_3']
    rng = np.random.default_rng(1)
    data = np.abs(rng.normal(loc=50, scale=40, size=(len(genes), len(samples))))* (1 + np.array([1,1,1,2,2,2])[None,:]/2)
    df = pd.DataFrame(data, index=genes, columns=samples)
    return df

def load_breast_cancer(path='data-3.csv'):
    if Path(path).exists():
        df = pd.read_csv(path)
        # try to harmonize diagnosis column
        if 'diagnosis' not in df.columns and 'target' in df.columns:
            df['diagnosis'] = df['target'].map({0:'B',1:'M'})
        return df
    # fallback: use sklearn dataset
    try:
        from sklearn.datasets import load_breast_cancer
        bc = load_breast_cancer(as_frame=True)
        df = bc.frame.copy()
        # rename columns to match mean feature names if necessary
        # sklearn feature names include 'mean' suffix already
        # create diagnosis column: 0=malignant? actually target: 0=malignant? check
        # sklearn.target: 0=malignant? We'll map by target names available
        df['diagnosis'] = df['target'].map({0:'M',1:'B'})
        # But sometimes mapping reversed; provide informative mapping by checking means
        return df
    except Exception:
        # synthetic fallback
        rng = np.random.default_rng(3)
        n = 200
        diagnosis = rng.choice(['M','B'], size=n, p=[0.4,0.6])
        df = pd.DataFrame({
            'radius_mean': rng.normal(14,3,size=n) + (diagnosis=='M')*3,
            'texture_mean': rng.normal(18,4,size=n) - (diagnosis=='M')*1,
            'perimeter_mean': rng.normal(87,20,size=n) + (diagnosis=='M')*10,
            'area_mean': np.abs(rng.normal(600,200,size=n) + (diagnosis=='M')*200),
            'smoothness_mean': np.clip(rng.normal(0.1,0.02,size=n) + (diagnosis=='M')*0.01, 0.01, 1),
            'compactness_mean': np.clip(rng.normal(0.12,0.05,size=n) + (diagnosis=='M')*0.05, 0.0, 1),
            'diagnosis': diagnosis
        })
        return df

# ---------- Load data ----------
counts_df = load_normalized_counts('hbr_uhr_top_deg_normalized_counts.csv')
deg_df = load_deg_chr22('hbr_uhr_deg_chr22_with_significance.csv')
bc_df = load_breast_cancer('data-3.csv')


# Part A: Gene Expression Analysis
# a) Heatmap: clustered heatmap of top DE genes between HBR and UHR
# Determine top DE genes using absolute log2 fold change from deg_df if genes match


# If counts_df has many genes, select top N genes based on deg_df
N = 50
if 'gene' in deg_df.columns:
    # find intersection
    genes_in_both = [g for g in deg_df['gene'].astype(str).values if g in counts_df.index]
    if len(genes_in_both) >= N:
        top_genes = deg_df.set_index('gene').loc[genes_in_both].assign(absL=lambda x: x['log2FoldChange'].abs()).sort_values('absL', ascending=False).head(N).index.tolist()
    else:
        # select genes by highest variance in counts
        top_genes = counts_df.var(axis=1).sort_values(ascending=False).head(N).index.tolist()
else:
    top_genes = counts_df.var(axis=1).sort_values(ascending=False).head(N).index.tolist()


heat_df = counts_df.loc[top_genes]
# z-score normalize genes (rows) for visualization
heat_norm = (heat_df.sub(heat_df.mean(axis=1), axis=0)).div(heat_df.std(axis=1).replace(0,1), axis=0)


# Plot clustered heatmap
cg = sns.clustermap(heat_norm, cmap='Blues', figsize=(6,6), row_cluster=True, col_cluster=True, xticklabels=True, yticklabels=True)
cg.ax_heatmap.set_xlabel('Samples')
cg.ax_heatmap.set_ylabel('Genes')
plt.suptitle('A. Clustered heatmap (top differentially expressed genes)')
# save heatmap separately
heatmap_out = 'figure1A_heatmap.png'
plt.savefig(heatmap_out, bbox_inches='tight')
plt.close()

# b) Volcano plot
volc = deg_df.copy()
if 'padj' not in volc.columns:
    volc['padj'] = 1.0
volc['padj'] = volc['padj'].replace(0, 1e-300)
volc['-log10padj'] = -np.log10(volc['padj'])


# significance annotation
def sig_label(row, lfc_thresh=1, padj_thresh=0.05):
    if row['padj'] <= padj_thresh:
        if row['log2FoldChange'] >= lfc_thresh:
            return 'up'
        elif row['log2FoldChange'] <= -lfc_thresh:
            return 'down'
    return 'ns'


volc['significance'] = volc.apply(sig_label, axis=1)


# Plot volcano
plt.figure(figsize=(6,5))
color_map = {'up':'green','down':'orange','ns':'grey'}
for k,grp in volc.groupby('significance'):
    plt.scatter(grp['log2FoldChange'], grp['-log10padj'], c=color_map[k], label=k, alpha=0.7, edgecolor='none', s=40)
plt.axvline(1, linestyle='--', linewidth=1)
plt.axvline(-1, linestyle='--', linewidth=1)
plt.axhline(0, linestyle=':', linewidth=0.5)
plt.xlabel('log2FoldChange')
plt.ylabel('-log10(Padj)')
plt.title('B. Volcano plot (chromosome 22 DE results)')
plt.legend(title='significance')
plt.tight_layout()
volc_out = 'figure1B_volcano.png'
plt.savefig(volc_out)
plt.close()


# Part B: Breast Cancer Data Exploration
# standardize diagnosis column to 'M' and 'B'
if 'diagnosis' in bc_df.columns:
    bc_df['diagnosis'] = bc_df['diagnosis'].astype(str).str.upper().str[0]
else:
    # try alternate column names
    if 'target' in bc_df.columns:
        bc_df['diagnosis'] = bc_df['target'].map({0:'M',1:'B'})

# c) Scatter Plot (radius vs texture)
plt.figure(figsize=(5.5,4.5))
sns.scatterplot(data=bc_df, x='radius_mean', y='texture_mean', hue='diagnosis', palette={'M':'tab:blue','B':'tab:orange'}, alpha=0.8)
plt.title('C. texture_mean vs radius_mean')
plt.xlabel('radius_mean')
plt.ylabel('texture_mean')
plt.legend(title='diagnosis')
plt.tight_layout()
plt.savefig('figure1C_scatter_radius_texture.png')
plt.close()


# d) Correlation Heatmap for six key features
features = ['radius_mean','texture_mean','perimeter_mean','area_mean','smoothness_mean','compactness_mean']
# ensure features exist; if not, try to find closest matches
existing = [f for f in features if f in bc_df.columns]
if len(existing) < len(features):
    # try fuzzy match simple substitution: replace '-' or spaces
    for f in features:
        if f not in existing:
            for col in bc_df.columns:
                if col.lower().startswith(f.split('_')[0]):
                    existing.append(col)
                    break


corr_df = bc_df[existing].corr()
plt.figure(figsize=(6,5))
ax = sns.heatmap(corr_df, annot=True, fmt='.2f', cmap='Blues', vmin=-1, vmax=1, square=True)
ax.set_title('D. Correlation matrix (selected features)')
plt.tight_layout()
plt.savefig('figure1D_corr_heatmap.png')
plt.close()

# e) Scatter Plot (smoothness vs compactness)
plt.figure(figsize=(5.5,4.5))
sns.scatterplot(data=bc_df, x='smoothness_mean', y='compactness_mean', hue='diagnosis', palette={'M':'tab:blue','B':'tab:orange'}, alpha=0.8)
plt.title('E. compactness_mean vs smoothness_mean')
plt.xlabel('smoothness_mean')
plt.ylabel('compactness_mean')
plt.legend(title='diagnosis')
plt.tight_layout()
plt.savefig('figure1E_scatter_smoothness_compactness.png')
plt.close()


# f) Density Plot (area distribution)
plt.figure(figsize=(5.5,4.0))
if 'diagnosis' in bc_df.columns:
    for label,group in bc_df.groupby('diagnosis'):
        sns.kdeplot(group['area_mean'].dropna(), fill=False, label=label)
    plt.xlabel('area_mean')
    plt.ylabel('Density')
    plt.title('F. KDE of area_mean by diagnosis')
    plt.legend(title='diagnosis')
    plt.tight_layout()
    plt.savefig('figure1F_density_area.png')
    plt.close()
else:
    print('Diagnosis column missing: cannot plot density by diagnosis')


# Final: combine saved images into one multi-panel figure (optional)
from PIL import Image


# Attempt to assemble into a single canvas (3x2 layout). Use available images; if missing, skip slots.
slots = [('figure1A_heatmap.png','A'),('figure1B_volcano.png','B'),('figure1C_scatter_radius_texture.png','C'),('figure1D_corr_heatmap.png','D'),('figure1E_scatter_smoothness_compactness.png','E'),('figure1F_density_area.png','F')]
imgs = []
for fn,label in slots:
    if Path(fn).exists():
        imgs.append(Image.open(fn).convert('RGB'))
    else:
        # create blank placeholder
        placeholder = Image.new('RGB', (600,450), color=(255,255,255))
        imgs.append(placeholder)


# resize images to common thumbnail size
thumb_w, thumb_h = 600,450
imgs = [im.resize((thumb_w,thumb_h)) for im in imgs]


canvas = Image.new('RGB', (thumb_w*3, thumb_h*2), (255,255,255))
positions = [(0,0),(thumb_w,0),(thumb_w*2,0),(0,thumb_h),(thumb_w,thumb_h),(thumb_w*2,thumb_h)]
for im,pos in zip(imgs, positions):
    canvas.paste(im, pos)


canvas_out = 'figure1_panels.png'
canvas.save(canvas_out)


print('Saved individual panels and combined figure:', canvas_out)
print('Individual files:', heatmap_out, volc_out, 'figure1C_scatter_radius_texture.png', 'figure1D_corr_heatmap.png', 'figure1E_scatter_smoothness_compactness.png', 'figure1F_density_area.png')
print('\nIf you have your own files, place them in the same folder with names:')
print(' - hbr_uhr_top_deg_normalized_counts.csv (genes x samples, index=gene symbols)')
print(' - hbr_uhr_deg_chr22_with_significance.csv (columns: gene, log2FoldChange, padj)')
print(' - data-3.csv (include required columns; or script will use sklearn data)')